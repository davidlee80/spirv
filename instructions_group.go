// This file is subject to a 1-clause BSD license.
// Its contents can be found in the enclosed LICENSE file.

package spirv

import "errors"

// OpAsyncGroupCopy performs an asynchronous group copy of Num
// elements from Source to Destination. The asynchronous copy is performed by
// all work-items in a group.
type OpAsyncGroupCopy struct {
	ResultType  Id
	ResultId    Id
	Scope       ExecutionScope
	Destination Id
	Source      Id
	NumElements Id
	Stride      Id
	Event       Id
}

func (c *OpAsyncGroupCopy) Opcode() uint32 { return 219 }
func (c *OpAsyncGroupCopy) Optional() bool { return false }
func (c *OpAsyncGroupCopy) Verify() error {
	switch c.Scope {
	case ExecutionScopeSubgroup, ExecutionScopeWorkgroup:
	default:
		return errors.New("OpAsyncGroupCopy.Scope: must be Subgroup or Workgroup")
	}

	return nil
}

// OpWaitGroupEvents waits for events generated by OpAsyncGroupCopy operations
// to complete. The event objects pointed by Events List will be released after
// the wait is performed.
type OpWaitGroupEvents struct {
	ResultType Id
	ResultId   Id
	Scope      ExecutionScope
	NumEvents  Id
	EventsList Id
}

func (c *OpWaitGroupEvents) Opcode() uint32 { return 220 }
func (c *OpWaitGroupEvents) Optional() bool { return false }
func (c *OpWaitGroupEvents) Verify() error {
	switch c.Scope {
	case ExecutionScopeSubgroup, ExecutionScopeWorkgroup:
	default:
		return errors.New("OpWaitGroupEvents.Scope: must be Subgroup or Workgroup")
	}

	return nil
}

// OpGroupAll evaluates a predicate for all work-items in the group and
// returns true if predicate evaluates to true for all work-items in the
// group, otherwise returns false.
type OpGroupAll struct {
	ResultType Id
	ResultId   Id
	Scope      ExecutionScope
	Predicate  Id
}

func (c *OpGroupAll) Opcode() uint32 { return 221 }
func (c *OpGroupAll) Optional() bool { return false }
func (c *OpGroupAll) Verify() error {
	switch c.Scope {
	case ExecutionScopeSubgroup, ExecutionScopeWorkgroup:
	default:
		return errors.New("OpGroupAll.Scope: must be Subgroup or Workgroup")
	}

	return nil
}

// OpGroupAny evaluates a predicate for all work-items in the group and
// returns true if predicate evaluates to true for any work-item in the group,
// otherwise returns false
type OpGroupAny struct {
	ResultType Id
	ResultId   Id
	Scope      ExecutionScope
	Predicate  Id
}

func (c *OpGroupAny) Opcode() uint32 { return 222 }
func (c *OpGroupAny) Optional() bool { return false }
func (c *OpGroupAny) Verify() error {
	switch c.Scope {
	case ExecutionScopeSubgroup, ExecutionScopeWorkgroup:
	default:
		return errors.New("OpGroupAny.Scope: must be Subgroup or Workgroup")
	}

	return nil
}

// OpGroupBroadcast broadcasts a value for workitem identified by the
// local id to all work-items in the group.
type OpGroupBroadcast struct {
	ResultType Id
	ResultId   Id
	Scope      ExecutionScope
	Value      Id
	LocalId    Id
}

func (c *OpGroupBroadcast) Opcode() uint32 { return 223 }
func (c *OpGroupBroadcast) Optional() bool { return false }
func (c *OpGroupBroadcast) Verify() error {
	switch c.Scope {
	case ExecutionScopeSubgroup, ExecutionScopeWorkgroup:
	default:
		return errors.New("OpGroupBroadcast.Scope: must be Subgroup or Workgroup")
	}

	return nil
}

// OpGroupIAdd performs an integer add group operation specified for all
// values of X specified by work-items in the group.
type OpGroupIAdd struct {
	ResultType Id
	ResultId   Id
	Scope      ExecutionScope
	Operation  GroupOperation
	X          Id
}

func (c *OpGroupIAdd) Opcode() uint32 { return 224 }
func (c *OpGroupIAdd) Optional() bool { return false }
func (c *OpGroupIAdd) Verify() error {
	switch c.Scope {
	case ExecutionScopeSubgroup, ExecutionScopeWorkgroup:
	default:
		return errors.New("OpGroupIAdd.Scope: must be Subgroup or Workgroup")
	}

	return nil
}

// OpGroupFAdd performs a floating-point add group operation specified for
// all values of X specified by work-items in the group.
type OpGroupFAdd struct {
	ResultType Id
	ResultId   Id
	Scope      ExecutionScope
	Operation  GroupOperation
	X          Id
}

func (c *OpGroupFAdd) Opcode() uint32 { return 225 }
func (c *OpGroupFAdd) Optional() bool { return false }
func (c *OpGroupFAdd) Verify() error {
	switch c.Scope {
	case ExecutionScopeSubgroup, ExecutionScopeWorkgroup:
	default:
		return errors.New("OpGroupFAdd.Scope: must be Subgroup or Workgroup")
	}

	return nil
}

// OpGroupFMin performs a floating-point minimum group operation specified
// for all values of X specified by work-items in the group.
type OpGroupFMin struct {
	ResultType Id
	ResultId   Id
	Scope      ExecutionScope
	Operation  GroupOperation
	X          Id
}

func (c *OpGroupFMin) Opcode() uint32 { return 226 }
func (c *OpGroupFMin) Optional() bool { return false }
func (c *OpGroupFMin) Verify() error {
	switch c.Scope {
	case ExecutionScopeSubgroup, ExecutionScopeWorkgroup:
	default:
		return errors.New("OpGroupFMin.Scope: must be Subgroup or Workgroup")
	}

	return nil
}

// OpGroupUMin performs an unsigned integer minimum group operation specified
// for all values of X specified by work-items in the group.
type OpGroupUMin struct {
	ResultType Id
	ResultId   Id
	Scope      ExecutionScope
	Operation  GroupOperation
	X          Id
}

func (c *OpGroupUMin) Opcode() uint32 { return 227 }
func (c *OpGroupUMin) Optional() bool { return false }
func (c *OpGroupUMin) Verify() error {
	switch c.Scope {
	case ExecutionScopeSubgroup, ExecutionScopeWorkgroup:
	default:
		return errors.New("OpGroupUMin.Scope: must be Subgroup or Workgroup")
	}

	return nil
}

// OpGroupSMin performs a signed integer minimum group operation specified
// for all values of X specified by work-items in the group.
type OpGroupSMin struct {
	ResultType Id
	ResultId   Id
	Scope      ExecutionScope
	Operation  GroupOperation
	X          Id
}

func (c *OpGroupSMin) Opcode() uint32 { return 228 }
func (c *OpGroupSMin) Optional() bool { return false }
func (c *OpGroupSMin) Verify() error {
	switch c.Scope {
	case ExecutionScopeSubgroup, ExecutionScopeWorkgroup:
	default:
		return errors.New("OpGroupSMin.Scope: must be Subgroup or Workgroup")
	}

	return nil
}

// OpGroupFMax performs a floating-point maximum group operation specified
// for all values of X specified by work-items in the group
type OpGroupFMax struct {
	ResultType Id
	ResultId   Id
	Scope      ExecutionScope
	Operation  GroupOperation
	X          Id
}

func (c *OpGroupFMax) Opcode() uint32 { return 229 }
func (c *OpGroupFMax) Optional() bool { return false }
func (c *OpGroupFMax) Verify() error {
	switch c.Scope {
	case ExecutionScopeSubgroup, ExecutionScopeWorkgroup:
	default:
		return errors.New("OpGroupFMax.Scope: must be Subgroup or Workgroup")
	}

	return nil
}

// OpGroupUMax performs an unsigned integer maximum group operation specified
// for all values of X specified by work-items in the group
type OpGroupUMax struct {
	ResultType Id
	ResultId   Id
	Scope      ExecutionScope
	Operation  GroupOperation
	X          Id
}

func (c *OpGroupUMax) Opcode() uint32 { return 230 }
func (c *OpGroupUMax) Optional() bool { return false }
func (c *OpGroupUMax) Verify() error {
	switch c.Scope {
	case ExecutionScopeSubgroup, ExecutionScopeWorkgroup:
	default:
		return errors.New("OpGroupUMax.Scope: must be Subgroup or Workgroup")
	}

	return nil
}

// OpGroupSMax performs a signed integer maximum group operation specified
// for all values of X specified by work-items in the group
type OpGroupSMax struct {
	ResultType Id
	ResultId   Id
	Scope      ExecutionScope
	Operation  GroupOperation
	X          Id
}

func (c *OpGroupSMax) Opcode() uint32 { return 231 }
func (c *OpGroupSMax) Optional() bool { return false }
func (c *OpGroupSMax) Verify() error {
	switch c.Scope {
	case ExecutionScopeSubgroup, ExecutionScopeWorkgroup:
	default:
		return errors.New("OpGroupSMax.Scope: must be Subgroup or Workgroup")
	}

	return nil
}

func init() {
	Bind(func() Instruction { return &OpAsyncGroupCopy{} })
	Bind(func() Instruction { return &OpWaitGroupEvents{} })
	Bind(func() Instruction { return &OpGroupAll{} })
	Bind(func() Instruction { return &OpGroupAny{} })
	Bind(func() Instruction { return &OpGroupBroadcast{} })
	Bind(func() Instruction { return &OpGroupIAdd{} })
	Bind(func() Instruction { return &OpGroupFAdd{} })
	Bind(func() Instruction { return &OpGroupFMin{} })
	Bind(func() Instruction { return &OpGroupUMin{} })
	Bind(func() Instruction { return &OpGroupSMin{} })
	Bind(func() Instruction { return &OpGroupFMax{} })
	Bind(func() Instruction { return &OpGroupUMax{} })
	Bind(func() Instruction { return &OpGroupSMax{} })
}
